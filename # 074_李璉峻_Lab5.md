# 074_李璉峻_Lab5

程序员的角度看，单进程编程和多进程编程最大的区别之一在于并行性和并发性。

1. 并发性（Parallelism）:
   
  * 单进程编程： 一个进程按顺序执行指令。无法同时处理多个任务，必须等待一个任务完成后才能进行下一个任务。
  * 多进程编程： 多个进程可以并行执行。每个进程都是独立运行的，因此可以同时处理多个任务。

2. 并发性（Concurrency）：
  * 单进程编程： 通常在单线程中运行，虽然看起来像是同时执行多个任务，但实际上是通过时间片轮转来切换任务的。

  * 多进程编程： 可以在多线程或多进程中运行。每个线程或进程都是独立执行的，有助于同时处理多个任务。

3. 资源共享和通信：
  * 单进程编程： 由于无需共享数据和资源，因此相对简单。
  
  * 多进程编程： 需要考虑多个进程之间的资源共享和有效通信，因此需要处理同步和死锁等问题。


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

//修改后的 cpuio_bound() 函??明
void cpuio_bound(int last, int cpu_time, int io_time);

int main() {
    int num_processes = 3;  //所需?程?

    for (int i = 0; i < num_processes; ++i) {
        pid_t pid = fork();

        if (pid == -1) {
            //???理
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid == 0) {
            //子程序
            cpuio_bound(10, i + 1, 2 * (i + 1));  //?用?性化 cpuio_bound
            exit(EXIT_SUCCESS);
        }
    }

    //父?程
    for (int i = 0; i < num_processes; ++i) {
        int status;
        wait(&status);  //等待全部子程序?束
    }

    printf("All child processes have finished.\n");

    return 0;
}

//定?修改后的 cpuio_bound() 函?
void cpuio_bound(int last, int cpu_time, int io_time) {
    int current_time = 0;

    while (current_time < last) {
        if (cpu_time > 0) {
            printf("PID %d - CPU 工作 %d 秒\n", getpid(), cpu_time);
            current_time += cpu_time;
        }

        if (io_time > 0) {
            printf("PID %d - I/O 工作  %d 秒\n", getpid(), io_time);
            current_time += io_time;
        }
    }
}


// kernel/fork.c

// ...

int do_fork(...) {
    //?有代?
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

//修改后的 cpuio_bound() 函??明
void cpuio_bound(int last, int cpu_time, int io_time);

int main() {
    int num_processes = 3;  //所需?程?

    for (int i = 0; i < num_processes; ++i) {
        pid_t pid = fork();

        if (pid == -1) {
            //???理
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid == 0) {
            //子程序
            cpuio_bound(10, i + 1, 2 * (i + 1));  //?用?性化 cpuio_bound
            exit(EXIT_SUCCESS);
        }
    }

    //父?程
    for (int i = 0; i < num_processes; ++i) {
        int status;
        wait(&status);  //等待全部子程序?束
    }

    printf("All child processes have finished.\n");

    return 0;
}

//定?修改后的 cpuio_bound() 函?
void cpuio_bound(int last, int cpu_time, int io_time) {
    int current_time = 0;

    while (current_time < last) {
        if (cpu_time > 0) {
            printf("PID %d - CPU 工作 %d 秒\n", getpid(), cpu_time);
            current_time += cpu_time;
        }

        if (io_time > 0) {
            printf("PID %d - I/O 工作  %d 秒\n", getpid(), io_time);
            current_time += io_time;
        }
    }
}


    //添加新代?: ?入?行?迹
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

//修改后的 cpuio_bound() 函??明
void cpuio_bound(int last, int cpu_time, int io_time);

int main() {
    int num_processes = 4;  //所需?程?

    for (int i = 0; i < num_processes; ++i) {
        pid_t pid = fork();

        if (pid == -1) {
            //???理
            perror("fork");
            exit(EXIT_FAILURE);
        }
        else if (pid == 0) {
            //子程序
            cpuio_bound(10, i + 1, 2 * (i + 1));  //?用?性化 cpuio_bound
            exit(EXIT_SUCCESS);
        }
    }

    //父?程
    for (int i = 0; i < num_processes; ++i) {
        int status;
        wait(&status);  //等待全部子程序?束
    }

    printf("All child processes have finished.\n");

    return 0;
}

//定?修改后的 cpuio_bound() 函?
void cpuio_bound(int last, int cpu_time, int io_time) {
    int current_time = 0;

    while (current_time < last) {
        if (cpu_time > 0) {
            printf("PID %d - CPU 工作 %d 秒\n", getpid(), cpu_time);
            current_time += cpu_time;
        }

        if (io_time > 0) {
            printf("PID %d - I/O 工作  %d 秒\n", getpid(), io_time);
            current_time += io_time;
        }
    }
}
    printk("PID: %d, State: N, Time: %ld\n", current->pid, jiffies);

    

    return child_pid;
}


4. 编程模型：
  * 单进程编程： 主要关注顺序执行的指令流。

  * 多进程编程： 需要考虑并发性和并行性，因此在程序设计和实现时需要更多的考虑。


由于这些差异，多进程编程可以利用并行处理获得更高的性能，但同时也增加了同步和资源管理等方面的复杂性。
