# 074_李璉峻

### 074-lab1

#### head.s 工作原理:
head.s程序运行是32位保护模式下，其中主要包含初始设置的代码、时钟中断int 0x08的过程代码、系统调用中断int $0x80的过程代码以及任务A和任务B等的代码和数据。

其中初始设备工作主要包含:重新设备GDP表、设备系统定时器芯片、重新设备IDT表并设备时钟和系统调用中断门、移动到任务A中执行。

GDT全局代码段和数据段描述符的内容都设置为：基地址为0x0000；段限长值为0x07ff。因为颗粒度为1，所以段长度为8MB。

全局显示数据段被设置成：基地址为0xb8000；段限长值为0x0002，所以实际段长度为8KB，对应到显示内存区域上。

两个任务在LTD中代码段和数据段描述符的内容也都设置为：基地址为0x0000;段限长值为0x03ff，实际段长度为4MB。因此在线性地空间中这个“内核”地代码和数据段于人物的代码和数据段都从线性地址0开始并且由于没有采用页机制，所以它们都直接对应物理层地址0中开始。
在mead程序编译出的目标文件中以及最终得到的软盘映像文件中。

由于处于特权级的0代码不能直接把控制权移动到特区俺的代吗中执行，但中断返回操作是可以的，因此当初始化GDT、IDT和定时芯片结束后，我们就利用中断返回指令IRET来启动第1个任务。集体实现方法是在初始堆栈init_stack中人工设置一个返回环境，即把任务的TSS段选择符加载到任务寄存器LTR中、LDT选择符加载到LDTR中以后，
把任务0的用户指南栈（0x17:init_stack）代码指针（0幸福：task0)以及标志奇存器值压入栈中,然后执行返回指令IRET。该指令会弹出堆栈上的堆栈指南作为任务0瀛湖站指南，恢复假设的任务0的标志奇存器内容，并且弹出栈中代码指针放入CS:EIP奇存器中，从而开始执行任务0的代码，完成了从特权级0到特权级3代牧区的控制转移。

为了每隔10ms切换运行的任务，head.s程序中把定时器芯片8253的通道0的设置成每经过10ms就向中断控制芯片8259A发送一个时钟中断请求信号。PC的ROM BIOS开机时已经在8259A中把时钟终端请求信号设备成中断向量8，因此需要在中断8的处理过程中执行任务切换操作。任务切换的实现方法是查看current变量中当前运行任务号。如果current当前是0，就利用任务1 的TSS选择符作为数量执行远眺转指令，从而切换到任务1中执行，否则反之。

每个任务在执行时，会首先把一个字符的ASCII码放入寄存器AL中，然后调用系统中断调用int 0x80，而该系统调用处理过程则会调用一个简单的字符写屏子程序，把寄存器AL中的符号显示子啊屏幕上，同时把字符现实的屏幕的下一个位置记录下来，作为下一次显示字符的屏幕位置。在显示过一个字符后，任务代码会使用循环语句延迟一段时间，然后又跳转到任务代码开始继续循环执行，直到运行了10ms而发生了定时中断，从而代码会切换到另一个任务去运行。
对于任务A，寄存器AL中将始终存放字符“A”，而任务B运行时AL中始终存放字符“B”。

因此在程序运行时看到一连串的字符“A”和一连串的字符“B”连续不断地显示在屏幕上。